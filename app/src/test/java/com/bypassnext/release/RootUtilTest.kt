package com.bypassnext.release

import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

class TestMockShellExecutor : ShellExecutor {
    val executedCommands = mutableListOf<String>()
    val commandResponses = mutableMapOf<String, String>()

    override suspend fun execute(command: String): String {
        executedCommands.add(command)
        // Find a matching response or return empty string
        // Check for exact match first, then check if key is contained in command
        return commandResponses[command] ?: commandResponses.entries.find { command.contains(it.key) }?.value ?: ""
    }
}

class RootUtilTest {

    private lateinit var mockShellExecutor: TestMockShellExecutor
    private lateinit var originalShellExecutor: ShellExecutor
    private val TEST_DNS_ID = "test.dns.id"

    @Before
    fun setUp() {
        originalShellExecutor = RootUtil.shellExecutor
        mockShellExecutor = TestMockShellExecutor()
        RootUtil.shellExecutor = mockShellExecutor
    }

    @After
    fun tearDown() {
        RootUtil.shellExecutor = originalShellExecutor
    }

    @Test
    fun testGetEnablePrivacyScript() {
        val tempDir = "/data/local/tmp/filtered_certs"
        val script = RootUtil.getEnablePrivacyScript(TEST_DNS_ID, tempDir)

        // Verify key commands are present in the script
        assertTrue("Script should set private_dns_mode", script.contains("settings put global private_dns_mode hostname"))
        assertTrue("Script should set private_dns_specifier", script.contains("settings put global private_dns_specifier $TEST_DNS_ID"))
        assertTrue("Script should set TEMP_DIR", script.contains("TEMP_DIR=\"$tempDir\""))
        assertTrue("Script should create temp directory", script.contains("mkdir -p \"\$TEMP_DIR\""))
        assertTrue("Script should mount bind", script.contains("mount -o bind"))
        assertTrue("Script should include a success message", script.contains("Privacy Mode Activated"))
    }

    @Test
    fun testGetDisablePrivacyScript() {
        val tempDir = "/data/local/tmp/filtered_certs"
        val script = RootUtil.getDisablePrivacyScript(tempDir)

        // Verify key commands are present in the script
        assertTrue("Script should reset private_dns_mode", script.contains("settings put global private_dns_mode off"))
        assertTrue("Script should delete private_dns_specifier", script.contains("settings delete global private_dns_specifier"))
        assertTrue("Script should unmount certificates", script.contains("umount"))
        // Expect quotes around the path as generated by the script
        assertTrue("Script should clean up temp directory", script.contains("rm -rf \"$tempDir\""))
        assertTrue("Script should include a success message", script.contains("Privacy Mode Deactivated"))
    }

    @Test
    fun testCheckPrivacyStatus_Enabled() {
        val dnsMode = "hostname"
        val dnsSpecifier = TEST_DNS_ID
        assertTrue("Should return true when DNS mode is hostname and specifier matches NextDNS ID",
            RootUtil.checkPrivacyStatus(dnsMode, dnsSpecifier, TEST_DNS_ID))
    }

    @Test
    fun testCheckPrivacyStatus_Disabled() {
        val dnsMode = "off"
        val dnsSpecifier = ""
        assertFalse("Should return false when DNS mode is off",
            RootUtil.checkPrivacyStatus(dnsMode, dnsSpecifier, TEST_DNS_ID))
    }

    @Test
    fun testCheckPrivacyStatus_WrongMode() {
        val dnsMode = "private"
        val dnsSpecifier = TEST_DNS_ID
        assertFalse("Should return false when DNS mode is not hostname",
            RootUtil.checkPrivacyStatus(dnsMode, dnsSpecifier, TEST_DNS_ID))
    }

    @Test
    fun testCheckPrivacyStatus_WrongSpecifier() {
        val dnsMode = "hostname"
        val dnsSpecifier = "google.com"
        assertFalse("Should return false when DNS specifier is not NextDNS ID",
            RootUtil.checkPrivacyStatus(dnsMode, dnsSpecifier, TEST_DNS_ID))
    }

    @Test
    fun testCheckPrivacyStatus_EmptyInputs() {
        assertFalse("Should return false for empty inputs",
            RootUtil.checkPrivacyStatus("", "", TEST_DNS_ID))
    }

    @Test
    fun testCheckPrivacyStatus_WithWhitespace() {
        // Note: The caller (isPrivacyModeEnabled) is responsible for trimming,
        // so checkPrivacyStatus expects exact matches.
        // If we pass whitespace, it should fail.
        val dnsMode = "hostname "
        val dnsSpecifier = TEST_DNS_ID
        assertFalse("Should return false if inputs contain whitespace (caller trims)",
            RootUtil.checkPrivacyStatus(dnsMode, dnsSpecifier, TEST_DNS_ID))
    }

    @Test
    fun testEnablePrivacyMode_DefaultDir() = runTest {
        val tempDir = "/data/local/tmp/filtered_certs"
        RootUtil.enablePrivacyMode(TEST_DNS_ID, tempDir)

        val executedScript = mockShellExecutor.executedCommands.joinToString("\n")
        assertTrue("Script should enable private_dns_mode", executedScript.contains("settings put global private_dns_mode hostname"))
        assertTrue("Script should set private_dns_specifier", executedScript.contains("settings put global private_dns_specifier $TEST_DNS_ID"))
        assertTrue("Script should create temp directory", executedScript.contains("mkdir -p"))
        assertTrue("Script should mount bind", executedScript.contains("mount -o bind"))
        assertTrue("Script should use provided temp dir", executedScript.contains("TEMP_DIR=\"$tempDir\""))
    }

    @Test
    fun testEnablePrivacyMode_CustomDir() = runTest {
        val customDir = "/data/local/tmp/custom_certs"
        RootUtil.enablePrivacyMode(TEST_DNS_ID, customDir)

        val executedScript = mockShellExecutor.executedCommands.joinToString("\n")
        assertTrue("Script should use custom temp dir", executedScript.contains("TEMP_DIR=\"$customDir\""))
        assertTrue("Script should remove custom temp dir before creating", executedScript.contains("rm -rf \"\$TEMP_DIR\""))
    }

    @Test
    fun testDisablePrivacyMode() = runTest {
        val tempDir = "/data/local/tmp/filtered_certs"
        RootUtil.disablePrivacyMode(tempDir)

        val executedScript = mockShellExecutor.executedCommands.joinToString("\n")
        assertTrue("Script should reset private_dns_mode", executedScript.contains("settings put global private_dns_mode off"))
        assertTrue("Script should delete private_dns_specifier", executedScript.contains("settings delete global private_dns_specifier"))
        assertTrue("Script should unmount certificates", executedScript.contains("umount"))
    }

    @Test
    fun testIsPrivacyModeEnabled_True() = runTest {
        mockShellExecutor.commandResponses["settings get global private_dns_mode"] = "hostname"
        mockShellExecutor.commandResponses["settings get global private_dns_specifier"] = TEST_DNS_ID

        assertTrue("Should return true when settings are correct", RootUtil.isPrivacyModeEnabled(TEST_DNS_ID))
    }

    @Test
    fun testIsPrivacyModeEnabled_False_WrongMode() = runTest {
        mockShellExecutor.commandResponses["settings get global private_dns_mode"] = "off"
        mockShellExecutor.commandResponses["settings get global private_dns_specifier"] = TEST_DNS_ID

        assertFalse("Should return false when mode is off", RootUtil.isPrivacyModeEnabled(TEST_DNS_ID))
    }

    @Test
    fun testIsPrivacyModeEnabled_False_WrongSpecifier() = runTest {
        mockShellExecutor.commandResponses["settings get global private_dns_mode"] = "hostname"
        mockShellExecutor.commandResponses["settings get global private_dns_specifier"] = "wrong.dns"

        assertFalse("Should return false when specifier is wrong", RootUtil.isPrivacyModeEnabled(TEST_DNS_ID))
    }

    @Test
    fun testIsRootAvailable_True() = runTest {
        mockShellExecutor.commandResponses["id"] = "uid=0(root) gid=0(root) groups=0(root)"
        assertTrue("Should return true when id command succeeds", RootUtil.isRootAvailable())
    }

    @Test
    fun testIsRootAvailable_False() = runTest {
        mockShellExecutor.commandResponses["id"] = "Error: su denied"
        assertFalse("Should return false when id command returns error", RootUtil.isRootAvailable())
    }
}
